"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/games/roulette/page",{

/***/ "(app-pages-browser)/./src/lib/gameSessionStorage.ts":
/*!***************************************!*\
  !*** ./src/lib/gameSessionStorage.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateUserStats: () => (/* binding */ calculateUserStats),\n/* harmony export */   clearGameSessions: () => (/* binding */ clearGameSessions),\n/* harmony export */   getDailyStats: () => (/* binding */ getDailyStats),\n/* harmony export */   getGameSessions: () => (/* binding */ getGameSessions),\n/* harmony export */   getGameSessionsByType: () => (/* binding */ getGameSessionsByType),\n/* harmony export */   getGameTypeStats: () => (/* binding */ getGameTypeStats),\n/* harmony export */   getRecentGameSessions: () => (/* binding */ getRecentGameSessions),\n/* harmony export */   getUserGameSessions: () => (/* binding */ getUserGameSessions),\n/* harmony export */   saveGameSession: () => (/* binding */ saveGameSession)\n/* harmony export */ });\n// Game Session Management für localStorage\n// Spielsession speichern\nfunction saveGameSession(session) {\n    try {\n        const existingSessions = getGameSessions();\n        const newSession = {\n            ...session,\n            id: generateSessionId(),\n            date: new Date().toISOString()\n        };\n        const updatedSessions = [\n            ...existingSessions,\n            newSession\n        ];\n        // Nur die letzten 1000 Sessions behalten\n        if (updatedSessions.length > 1000) {\n            updatedSessions.splice(0, updatedSessions.length - 1000);\n        }\n        localStorage.setItem('casino_game_sessions', JSON.stringify(updatedSessions));\n        return newSession;\n    } catch (error) {\n        console.error('Fehler beim Speichern der Spielsession:', error);\n        return null;\n    }\n}\n// Alle Spielsessions laden\nfunction getGameSessions() {\n    try {\n        const savedSessions = localStorage.getItem('casino_game_sessions');\n        return savedSessions ? JSON.parse(savedSessions) : [];\n    } catch (error) {\n        console.error('Fehler beim Laden der Spielsessions:', error);\n        return [];\n    }\n}\n// Letzte N Spielsessions laden\nfunction getRecentGameSessions() {\n    let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;\n    const sessions = getGameSessions();\n    return sessions.slice(-limit).reverse(); // Neueste zuerst\n}\n// Spielsessions für einen bestimmten Benutzer laden\nfunction getUserGameSessions(userId) {\n    const sessions = getGameSessions();\n    return sessions.filter((session)=>session.userId === userId);\n}\n// Spielsessions nach Spieltyp filtern\nfunction getGameSessionsByType(gameType) {\n    const sessions = getGameSessions();\n    return sessions.filter((session)=>session.gameType === gameType);\n}\n// Alle Spielsessions löschen\nfunction clearGameSessions() {\n    try {\n        localStorage.removeItem('casino_game_sessions');\n        return true;\n    } catch (error) {\n        console.error('Fehler beim Löschen der Spielsessions:', error);\n        return false;\n    }\n}\n// Session ID generieren\nfunction generateSessionId() {\n    return 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2);\n}\n// Statistiken berechnen\nfunction calculateUserStats(sessions) {\n    if (sessions.length === 0) {\n        return {\n            totalGames: 0,\n            totalWins: 0,\n            totalLosses: 0,\n            totalPushes: 0,\n            totalWagered: 0,\n            totalWon: 0,\n            netProfit: 0,\n            winRate: 0,\n            favoriteGame: null,\n            biggestWin: 0,\n            biggestLoss: 0,\n            averageBet: 0,\n            averageWin: 0,\n            sessionsToday: 0,\n            profitToday: 0\n        };\n    }\n    const totalGames = sessions.length;\n    const totalWins = sessions.filter((s)=>s.result === 'win').length;\n    const totalLosses = sessions.filter((s)=>s.result === 'lose').length;\n    const totalPushes = sessions.filter((s)=>s.result === 'push').length;\n    const totalWagered = sessions.reduce((sum, s)=>sum + s.betAmount, 0);\n    const totalWon = sessions.reduce((sum, s)=>sum + s.winAmount, 0);\n    const netProfit = sessions.reduce((sum, s)=>sum + s.profit, 0);\n    const winRate = totalGames > 0 ? totalWins / totalGames * 100 : 0;\n    // Beliebtestes Spiel\n    const gameTypeCounts = sessions.reduce((counts, session)=>{\n        counts[session.gameType] = (counts[session.gameType] || 0) + 1;\n        return counts;\n    }, {});\n    const favoriteGame = Object.keys(gameTypeCounts).length > 0 ? Object.entries(gameTypeCounts).reduce((a, b)=>gameTypeCounts[a[0]] > gameTypeCounts[b[0]] ? a : b)[0] : null;\n    const biggestWin = Math.max(...sessions.map((s)=>s.profit), 0);\n    const biggestLoss = Math.min(...sessions.map((s)=>s.profit), 0);\n    const averageBet = totalWagered / totalGames;\n    const averageWin = totalWins > 0 ? totalWon / totalWins : 0;\n    // Sessions und Profit heute\n    const today = new Date().toDateString();\n    const sessionsToday = sessions.filter((s)=>new Date(s.date).toDateString() === today).length;\n    const profitToday = sessions.filter((s)=>new Date(s.date).toDateString() === today).reduce((sum, s)=>sum + s.profit, 0);\n    return {\n        totalGames,\n        totalWins,\n        totalLosses,\n        totalPushes,\n        totalWagered,\n        totalWon,\n        netProfit,\n        winRate,\n        favoriteGame,\n        biggestWin,\n        biggestLoss,\n        averageBet,\n        averageWin,\n        sessionsToday,\n        profitToday\n    };\n}\n// Tägliche Statistiken für die letzten 7 Tage\nfunction getDailyStats(sessions) {\n    let days = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 7;\n    const result = [];\n    for(let i = days - 1; i >= 0; i--){\n        const date = new Date();\n        date.setDate(date.getDate() - i);\n        const dayStart = new Date(date);\n        dayStart.setHours(0, 0, 0, 0);\n        const dayEnd = new Date(date);\n        dayEnd.setHours(23, 59, 59, 999);\n        const daySessions = sessions.filter((session)=>{\n            const sessionDate = new Date(session.date);\n            return sessionDate >= dayStart && sessionDate <= dayEnd;\n        });\n        const profit = daySessions.reduce((sum, session)=>sum + session.profit, 0);\n        const gamesPlayed = daySessions.length;\n        const wagered = daySessions.reduce((sum, session)=>sum + session.betAmount, 0);\n        const won = daySessions.reduce((sum, session)=>sum + session.winAmount, 0);\n        result.push({\n            date: date.toLocaleDateString('de-DE', {\n                weekday: 'short'\n            }),\n            fullDate: date.toISOString().split('T')[0],\n            profit,\n            gamesPlayed,\n            wagered,\n            won\n        });\n    }\n    return result;\n}\n// Game-spezifische Statistiken\nfunction getGameTypeStats(sessions) {\n    const gameTypes = [\n        'blackjack',\n        'roulette',\n        'slots'\n    ];\n    return gameTypes.map((gameType)=>{\n        const gameSessions = sessions.filter((s)=>s.gameType === gameType);\n        const stats = calculateUserStats(gameSessions);\n        return {\n            gameType,\n            ...stats\n        };\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZ2FtZVNlc3Npb25TdG9yYWdlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLDJDQUEyQztBQWEzQyx5QkFBeUI7QUFDbEIsU0FBU0EsZ0JBQWdCQyxPQUErQztJQUM3RSxJQUFJO1FBQ0YsTUFBTUMsbUJBQW1CQztRQUN6QixNQUFNQyxhQUFnQztZQUNwQyxHQUFHSCxPQUFPO1lBQ1ZJLElBQUlDO1lBQ0pDLE1BQU0sSUFBSUMsT0FBT0MsV0FBVztRQUM5QjtRQUVBLE1BQU1DLGtCQUFrQjtlQUFJUjtZQUFrQkU7U0FBVztRQUV6RCx5Q0FBeUM7UUFDekMsSUFBSU0sZ0JBQWdCQyxNQUFNLEdBQUcsTUFBTTtZQUNqQ0QsZ0JBQWdCRSxNQUFNLENBQUMsR0FBR0YsZ0JBQWdCQyxNQUFNLEdBQUc7UUFDckQ7UUFFQUUsYUFBYUMsT0FBTyxDQUFDLHdCQUF3QkMsS0FBS0MsU0FBUyxDQUFDTjtRQUM1RCxPQUFPTjtJQUNULEVBQUUsT0FBT2EsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsMkNBQTJDQTtRQUN6RCxPQUFPO0lBQ1Q7QUFDRjtBQUVBLDJCQUEyQjtBQUNwQixTQUFTZDtJQUNkLElBQUk7UUFDRixNQUFNZ0IsZ0JBQWdCTixhQUFhTyxPQUFPLENBQUM7UUFDM0MsT0FBT0QsZ0JBQWdCSixLQUFLTSxLQUFLLENBQUNGLGlCQUFpQixFQUFFO0lBQ3ZELEVBQUUsT0FBT0YsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsd0NBQXdDQTtRQUN0RCxPQUFPLEVBQUU7SUFDWDtBQUNGO0FBRUEsK0JBQStCO0FBQ3hCLFNBQVNLO1FBQXNCQyxRQUFBQSxpRUFBZ0I7SUFDcEQsTUFBTUMsV0FBV3JCO0lBQ2pCLE9BQU9xQixTQUFTQyxLQUFLLENBQUMsQ0FBQ0YsT0FBT0csT0FBTyxJQUFJLGlCQUFpQjtBQUM1RDtBQUVBLG9EQUFvRDtBQUM3QyxTQUFTQyxvQkFBb0JDLE1BQWM7SUFDaEQsTUFB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RSxLQUFLUCxRQUFRTSxJQUFJO1lBQ3pDLE9BQU80RSxlQUFlSixZQUFZSSxlQUFlRjtRQUNuRDtRQUVBLE1BQU1wQixTQUFTcUIsWUFBWXpCLE1BQU0sQ0FBQyxDQUFDQyxLQUFLekQsVUFBWXlELE1BQU16RCxRQUFRNEQsTUFBTSxFQUFFO1FBQzFFLE1BQU11QixjQUFjRixZQUFZdkUsTUFBTTtRQUN0QyxNQUFNMEUsVUFBVUgsWUFBWXpCLE1BQU0sQ0FBQyxDQUFDQyxLQUFLekQsVUFBWXlELE1BQU16RCxRQUFRMEQsU0FBUyxFQUFFO1FBQzlFLE1BQU0yQixNQUFNSixZQUFZekIsTUFBTSxDQUFDLENBQUNDLEtBQUt6RCxVQUFZeUQsTUFBTXpELFFBQVEyRCxTQUFTLEVBQUU7UUFFMUVKLE9BQU8rQixJQUFJLENBQUM7WUFDVmhGLE1BQU1BLEtBQUtpRixrQkFBa0IsQ0FBQyxTQUFTO2dCQUFFQyxTQUFTO1lBQVE7WUFDMURDLFVBQVVuRixLQUFLRSxXQUFXLEdBQUdrRixLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDMUM5QjtZQUNBdUI7WUFDQUM7WUFDQUM7UUFDRjtJQUNGO0lBRUEsT0FBTzlCO0FBQ1Q7QUFFQSwrQkFBK0I7QUFDeEIsU0FBU29DLGlCQUFpQnBFLFFBQTZCO0lBQzVELE1BQU1xRSxZQUFZO1FBQUM7UUFBYTtRQUFZO0tBQVE7SUFFcEQsT0FBT0EsVUFBVXZCLEdBQUcsQ0FBQ3ZDLENBQUFBO1FBQ25CLE1BQU0rRCxlQUFldEUsU0FBU0ssTUFBTSxDQUFDMEIsQ0FBQUEsSUFBS0EsRUFBRXhCLFFBQVEsS0FBS0E7UUFDekQsTUFBTWdFLFFBQVF4RCxtQkFBbUJ1RDtRQUVqQyxPQUFPO1lBQ0wvRDtZQUNBLEdBQUdnRSxLQUFLO1FBQ1Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvd29ya3NwYWNlcy9PbmxpbmVDYXNpbm8vc3JjL2xpYi9nYW1lU2Vzc2lvblN0b3JhZ2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2FtZSBTZXNzaW9uIE1hbmFnZW1lbnQgZsO8ciBsb2NhbFN0b3JhZ2VcblxuZXhwb3J0IGludGVyZmFjZSBTdG9yZWRHYW1lU2Vzc2lvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIGdhbWVUeXBlOiAnYmxhY2tqYWNrJyB8ICdyb3VsZXR0ZScgfCAnc2xvdHMnO1xuICBiZXRBbW91bnQ6IG51bWJlcjtcbiAgd2luQW1vdW50OiBudW1iZXI7XG4gIHJlc3VsdDogJ3dpbicgfCAnbG9zZScgfCAncHVzaCc7XG4gIGRhdGU6IHN0cmluZzsgLy8gSVNPIFN0cmluZ1xuICBwcm9maXQ6IG51bWJlcjtcbiAgdXNlcklkPzogc3RyaW5nO1xufVxuXG4vLyBTcGllbHNlc3Npb24gc3BlaWNoZXJuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUdhbWVTZXNzaW9uKHNlc3Npb246IE9taXQ8U3RvcmVkR2FtZVNlc3Npb24sICdpZCcgfCAnZGF0ZSc+KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZXhpc3RpbmdTZXNzaW9ucyA9IGdldEdhbWVTZXNzaW9ucygpO1xuICAgIGNvbnN0IG5ld1Nlc3Npb246IFN0b3JlZEdhbWVTZXNzaW9uID0ge1xuICAgICAgLi4uc2Vzc2lvbixcbiAgICAgIGlkOiBnZW5lcmF0ZVNlc3Npb25JZCgpLFxuICAgICAgZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcblxuICAgIGNvbnN0IHVwZGF0ZWRTZXNzaW9ucyA9IFsuLi5leGlzdGluZ1Nlc3Npb25zLCBuZXdTZXNzaW9uXTtcbiAgICBcbiAgICAvLyBOdXIgZGllIGxldHp0ZW4gMTAwMCBTZXNzaW9ucyBiZWhhbHRlblxuICAgIGlmICh1cGRhdGVkU2Vzc2lvbnMubGVuZ3RoID4gMTAwMCkge1xuICAgICAgdXBkYXRlZFNlc3Npb25zLnNwbGljZSgwLCB1cGRhdGVkU2Vzc2lvbnMubGVuZ3RoIC0gMTAwMCk7XG4gICAgfVxuXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2Nhc2lub19nYW1lX3Nlc3Npb25zJywgSlNPTi5zdHJpbmdpZnkodXBkYXRlZFNlc3Npb25zKSk7XG4gICAgcmV0dXJuIG5ld1Nlc3Npb247XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmVobGVyIGJlaW0gU3BlaWNoZXJuIGRlciBTcGllbHNlc3Npb246JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIEFsbGUgU3BpZWxzZXNzaW9ucyBsYWRlblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdhbWVTZXNzaW9ucygpOiBTdG9yZWRHYW1lU2Vzc2lvbltdIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzYXZlZFNlc3Npb25zID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2Nhc2lub19nYW1lX3Nlc3Npb25zJyk7XG4gICAgcmV0dXJuIHNhdmVkU2Vzc2lvbnMgPyBKU09OLnBhcnNlKHNhdmVkU2Vzc2lvbnMpIDogW107XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmVobGVyIGJlaW0gTGFkZW4gZGVyIFNwaWVsc2Vzc2lvbnM6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vLyBMZXR6dGUgTiBTcGllbHNlc3Npb25zIGxhZGVuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVjZW50R2FtZVNlc3Npb25zKGxpbWl0OiBudW1iZXIgPSAxMCk6IFN0b3JlZEdhbWVTZXNzaW9uW10ge1xuICBjb25zdCBzZXNzaW9ucyA9IGdldEdhbWVTZXNzaW9ucygpO1xuICByZXR1cm4gc2Vzc2lvbnMuc2xpY2UoLWxpbWl0KS5yZXZlcnNlKCk7IC8vIE5ldWVzdGUgenVlcnN0XG59XG5cbi8vIFNwaWVsc2Vzc2lvbnMgZsO8ciBlaW5lbiBiZXN0aW1tdGVuIEJlbnV0emVyIGxhZGVuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlckdhbWVTZXNzaW9ucyh1c2VySWQ6IHN0cmluZyk6IFN0b3JlZEdhbWVTZXNzaW9uW10ge1xuICBjb25zdCBzZXNzaW9ucyA9IGdldEdhbWVTZXNzaW9ucygpO1xuICByZXR1cm4gc2Vzc2lvbnMuZmlsdGVyKHNlc3Npb24gPT4gc2Vzc2lvbi51c2VySWQgPT09IHVzZXJJZCk7XG59XG5cbi8vIFNwaWVsc2Vzc2lvbnMgbmFjaCBTcGllbHR5cCBmaWx0ZXJuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2FtZVNlc3Npb25zQnlUeXBlKGdhbWVUeXBlOiBzdHJpbmcpOiBTdG9yZWRHYW1lU2Vzc2lvbltdIHtcbiAgY29uc3Qgc2Vzc2lvbnMgPSBnZXRHYW1lU2Vzc2lvbnMoKTtcbiAgcmV0dXJuIHNlc3Npb25zLmZpbHRlcihzZXNzaW9uID0+IHNlc3Npb24uZ2FtZVR5cGUgPT09IGdhbWVUeXBlKTtcbn1cblxuLy8gQWxsZSBTcGllbHNlc3Npb25zIGzDtnNjaGVuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJHYW1lU2Vzc2lvbnMoKSB7XG4gIHRyeSB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2Nhc2lub19nYW1lX3Nlc3Npb25zJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmVobGVyIGJlaW0gTMO2c2NoZW4gZGVyIFNwaWVsc2Vzc2lvbnM6JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBTZXNzaW9uIElEIGdlbmVyaWVyZW5cbmZ1bmN0aW9uIGdlbmVyYXRlU2Vzc2lvbklkKCk6IHN0cmluZyB7XG4gIHJldHVybiAnc2Vzc2lvbl8nICsgRGF0ZS5ub3coKSArICdfJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcbn1cblxuLy8gU3RhdGlzdGlrZW4gYmVyZWNobmVuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlVXNlclN0YXRzKHNlc3Npb25zOiBTdG9yZWRHYW1lU2Vzc2lvbltdKSB7XG4gIGlmIChzZXNzaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxHYW1lczogMCxcbiAgICAgIHRvdGFsV2luczogMCxcbiAgICAgIHRvdGFsTG9zc2VzOiAwLFxuICAgICAgdG90YWxQdXNoZXM6IDAsXG4gICAgICB0b3RhbFdhZ2VyZWQ6IDAsXG4gICAgICB0b3RhbFdvbjogMCxcbiAgICAgIG5ldFByb2ZpdDogMCxcbiAgICAgIHdpblJhdGU6IDAsXG4gICAgICBmYXZvcml0ZUdhbWU6IG51bGwsXG4gICAgICBiaWdnZXN0V2luOiAwLFxuICAgICAgYmlnZ2VzdExvc3M6IDAsXG4gICAgICBhdmVyYWdlQmV0OiAwLFxuICAgICAgYXZlcmFnZVdpbjogMCxcbiAgICAgIHNlc3Npb25zVG9kYXk6IDAsXG4gICAgICBwcm9maXRUb2RheTogMFxuICAgIH07XG4gIH1cblxuICBjb25zdCB0b3RhbEdhbWVzID0gc2Vzc2lvbnMubGVuZ3RoO1xuICBjb25zdCB0b3RhbFdpbnMgPSBzZXNzaW9ucy5maWx0ZXIocyA9PiBzLnJlc3VsdCA9PT0gJ3dpbicpLmxlbmd0aDtcbiAgY29uc3QgdG90YWxMb3NzZXMgPSBzZXNzaW9ucy5maWx0ZXIocyA9PiBzLnJlc3VsdCA9PT0gJ2xvc2UnKS5sZW5ndGg7XG4gIGNvbnN0IHRvdGFsUHVzaGVzID0gc2Vzc2lvbnMuZmlsdGVyKHMgPT4gcy5yZXN1bHQgPT09ICdwdXNoJykubGVuZ3RoO1xuICBjb25zdCB0b3RhbFdhZ2VyZWQgPSBzZXNzaW9ucy5yZWR1Y2UoKHN1bSwgcykgPT4gc3VtICsgcy5iZXRBbW91bnQsIDApO1xuICBjb25zdCB0b3RhbFdvbiA9IHNlc3Npb25zLnJlZHVjZSgoc3VtLCBzKSA9PiBzdW0gKyBzLndpbkFtb3VudCwgMCk7XG4gIGNvbnN0IG5ldFByb2ZpdCA9IHNlc3Npb25zLnJlZHVjZSgoc3VtLCBzKSA9PiBzdW0gKyBzLnByb2ZpdCwgMCk7XG4gIGNvbnN0IHdpblJhdGUgPSB0b3RhbEdhbWVzID4gMCA/ICh0b3RhbFdpbnMgLyB0b3RhbEdhbWVzKSAqIDEwMCA6IDA7XG5cbiAgLy8gQmVsaWVidGVzdGVzIFNwaWVsXG4gIGNvbnN0IGdhbWVUeXBlQ291bnRzID0gc2Vzc2lvbnMucmVkdWNlKChjb3VudHMsIHNlc3Npb24pID0+IHtcbiAgICBjb3VudHNbc2Vzc2lvbi5nYW1lVHlwZV0gPSAoY291bnRzW3Nlc3Npb24uZ2FtZVR5cGVdIHx8IDApICsgMTtcbiAgICByZXR1cm4gY291bnRzO1xuICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KTtcblxuICBjb25zdCBmYXZvcml0ZUdhbWUgPSBPYmplY3Qua2V5cyhnYW1lVHlwZUNvdW50cykubGVuZ3RoID4gMCBcbiAgICA/IE9iamVjdC5lbnRyaWVzKGdhbWVUeXBlQ291bnRzKS5yZWR1Y2UoKGEsIGIpID0+IFxuICAgICAgICBnYW1lVHlwZUNvdW50c1thWzBdXSA+IGdhbWVUeXBlQ291bnRzW2JbMF1dID8gYSA6IGJcbiAgICAgIClbMF0gXG4gICAgOiBudWxsO1xuXG4gIGNvbnN0IGJpZ2dlc3RXaW4gPSBNYXRoLm1heCguLi5zZXNzaW9ucy5tYXAocyA9PiBzLnByb2ZpdCksIDApO1xuICBjb25zdCBiaWdnZXN0TG9zcyA9IE1hdGgubWluKC4uLnNlc3Npb25zLm1hcChzID0+IHMucHJvZml0KSwgMCk7XG4gIGNvbnN0IGF2ZXJhZ2VCZXQgPSB0b3RhbFdhZ2VyZWQgLyB0b3RhbEdhbWVzO1xuICBjb25zdCBhdmVyYWdlV2luID0gdG90YWxXaW5zID4gMCA/IHRvdGFsV29uIC8gdG90YWxXaW5zIDogMDtcblxuICAvLyBTZXNzaW9ucyB1bmQgUHJvZml0IGhldXRlXG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0RhdGVTdHJpbmcoKTtcbiAgY29uc3Qgc2Vzc2lvbnNUb2RheSA9IHNlc3Npb25zLmZpbHRlcihzID0+IFxuICAgIG5ldyBEYXRlKHMuZGF0ZSkudG9EYXRlU3RyaW5nKCkgPT09IHRvZGF5XG4gICkubGVuZ3RoO1xuICBjb25zdCBwcm9maXRUb2RheSA9IHNlc3Npb25zXG4gICAgLmZpbHRlcihzID0+IG5ldyBEYXRlKHMuZGF0ZSkudG9EYXRlU3RyaW5nKCkgPT09IHRvZGF5KVxuICAgIC5yZWR1Y2UoKHN1bSwgcykgPT4gc3VtICsgcy5wcm9maXQsIDApO1xuXG4gIHJldHVybiB7XG4gICAgdG90YWxHYW1lcyxcbiAgICB0b3RhbFdpbnMsXG4gICAgdG90YWxMb3NzZXMsXG4gICAgdG90YWxQdXNoZXMsXG4gICAgdG90YWxXYWdlcmVkLFxuICAgIHRvdGFsV29uLFxuICAgIG5ldFByb2ZpdCxcbiAgICB3aW5SYXRlLFxuICAgIGZhdm9yaXRlR2FtZSxcbiAgICBiaWdnZXN0V2luLFxuICAgIGJpZ2dlc3RMb3NzLFxuICAgIGF2ZXJhZ2VCZXQsXG4gICAgYXZlcmFnZVdpbixcbiAgICBzZXNzaW9uc1RvZGF5LFxuICAgIHByb2ZpdFRvZGF5XG4gIH07XG59XG5cbi8vIFTDpGdsaWNoZSBTdGF0aXN0aWtlbiBmw7xyIGRpZSBsZXR6dGVuIDcgVGFnZVxuZXhwb3J0IGZ1bmN0aW9uIGdldERhaWx5U3RhdHMoc2Vzc2lvbnM6IFN0b3JlZEdhbWVTZXNzaW9uW10sIGRheXM6IG51bWJlciA9IDcpIHtcbiAgY29uc3QgcmVzdWx0OiBBcnJheTx7XG4gICAgZGF0ZTogc3RyaW5nO1xuICAgIGZ1bGxEYXRlOiBzdHJpbmc7XG4gICAgcHJvZml0OiBudW1iZXI7XG4gICAgZ2FtZXNQbGF5ZWQ6IG51bWJlcjtcbiAgICB3YWdlcmVkOiBudW1iZXI7XG4gICAgd29uOiBudW1iZXI7XG4gIH0+ID0gW107XG4gIFxuICBmb3IgKGxldCBpID0gZGF5cyAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gaSk7XG4gICAgY29uc3QgZGF5U3RhcnQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICBkYXlTdGFydC5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICBjb25zdCBkYXlFbmQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICBkYXlFbmQuc2V0SG91cnMoMjMsIDU5LCA1OSwgOTk5KTtcblxuICAgIGNvbnN0IGRheVNlc3Npb25zID0gc2Vzc2lvbnMuZmlsdGVyKHNlc3Npb24gPT4ge1xuICAgICAgY29uc3Qgc2Vzc2lvbkRhdGUgPSBuZXcgRGF0ZShzZXNzaW9uLmRhdGUpO1xuICAgICAgcmV0dXJuIHNlc3Npb25EYXRlID49IGRheVN0YXJ0ICYmIHNlc3Npb25EYXRlIDw9IGRheUVuZDtcbiAgICB9KTtcblxuICAgIGNvbnN0IHByb2ZpdCA9IGRheVNlc3Npb25zLnJlZHVjZSgoc3VtLCBzZXNzaW9uKSA9PiBzdW0gKyBzZXNzaW9uLnByb2ZpdCwgMCk7XG4gICAgY29uc3QgZ2FtZXNQbGF5ZWQgPSBkYXlTZXNzaW9ucy5sZW5ndGg7XG4gICAgY29uc3Qgd2FnZXJlZCA9IGRheVNlc3Npb25zLnJlZHVjZSgoc3VtLCBzZXNzaW9uKSA9PiBzdW0gKyBzZXNzaW9uLmJldEFtb3VudCwgMCk7XG4gICAgY29uc3Qgd29uID0gZGF5U2Vzc2lvbnMucmVkdWNlKChzdW0sIHNlc3Npb24pID0+IHN1bSArIHNlc3Npb24ud2luQW1vdW50LCAwKTtcblxuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIGRhdGU6IGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdkZS1ERScsIHsgd2Vla2RheTogJ3Nob3J0JyB9KSxcbiAgICAgIGZ1bGxEYXRlOiBkYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgIHByb2ZpdCxcbiAgICAgIGdhbWVzUGxheWVkLFxuICAgICAgd2FnZXJlZCxcbiAgICAgIHdvblxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR2FtZS1zcGV6aWZpc2NoZSBTdGF0aXN0aWtlblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdhbWVUeXBlU3RhdHMoc2Vzc2lvbnM6IFN0b3JlZEdhbWVTZXNzaW9uW10pIHtcbiAgY29uc3QgZ2FtZVR5cGVzID0gWydibGFja2phY2snLCAncm91bGV0dGUnLCAnc2xvdHMnXSBhcyBjb25zdDtcbiAgXG4gIHJldHVybiBnYW1lVHlwZXMubWFwKGdhbWVUeXBlID0+IHtcbiAgICBjb25zdCBnYW1lU2Vzc2lvbnMgPSBzZXNzaW9ucy5maWx0ZXIocyA9PiBzLmdhbWVUeXBlID09PSBnYW1lVHlwZSk7XG4gICAgY29uc3Qgc3RhdHMgPSBjYWxjdWxhdGVVc2VyU3RhdHMoZ2FtZVNlc3Npb25zKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgZ2FtZVR5cGUsXG4gICAgICAuLi5zdGF0c1xuICAgIH07XG4gIH0pO1xufVxuIl0sIm5hbWVzIjpbInNhdmVHYW1lU2Vzc2lvbiIsInNlc3Npb24iLCJleGlzdGluZ1Nlc3Npb25zIiwiZ2V0R2FtZVNlc3Npb25zIiwibmV3U2Vzc2lvbiIsImlkIiwiZ2VuZXJhdGVTZXNzaW9uSWQiLCJkYXRlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidXBkYXRlZFNlc3Npb25zIiwibGVuZ3RoIiwic3BsaWNlIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvciIsImNvbnNvbGUiLCJzYXZlZFNlc3Npb25zIiwiZ2V0SXRlbSIsInBhcnNlIiwiZ2V0UmVjZW50R2FtZVNlc3Npb25zIiwibGltaXQiLCJzZXNzaW9ucyIsInNsaWNlIiwicmV2ZXJzZSIsImdldFVzZXJHYW1lU2Vzc2lvbnMiLCJ1c2VySWQiLCJmaWx0ZXIiLCJnZXRHYW1lU2Vzc2lvbnNCeVR5cGUiLCJnYW1lVHlwZSIsImNsZWFyR2FtZVNlc3Npb25zIiwicmVtb3ZlSXRlbSIsIm5vdyIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsImNhbGN1bGF0ZVVzZXJTdGF0cyIsInRvdGFsR2FtZXMiLCJ0b3RhbFdpbnMiLCJ0b3RhbExvc3NlcyIsInRvdGFsUHVzaGVzIiwidG90YWxXYWdlcmVkIiwidG90YWxXb24iLCJuZXRQcm9maXQiLCJ3aW5SYXRlIiwiZmF2b3JpdGVHYW1lIiwiYmlnZ2VzdFdpbiIsImJpZ2dlc3RMb3NzIiwiYXZlcmFnZUJldCIsImF2ZXJhZ2VXaW4iLCJzZXNzaW9uc1RvZGF5IiwicHJvZml0VG9kYXkiLCJzIiwicmVzdWx0IiwicmVkdWNlIiwic3VtIiwiYmV0QW1vdW50Iiwid2luQW1vdW50IiwicHJvZml0IiwiZ2FtZVR5cGVDb3VudHMiLCJjb3VudHMiLCJPYmplY3QiLCJrZXlzIiwiZW50cmllcyIsImEiLCJiIiwibWF4IiwibWFwIiwibWluIiwidG9kYXkiLCJ0b0RhdGVTdHJpbmciLCJnZXREYWlseVN0YXRzIiwiZGF5cyIsImkiLCJzZXREYXRlIiwiZ2V0RGF0ZSIsImRheVN0YXJ0Iiwic2V0SG91cnMiLCJkYXlFbmQiLCJkYXlTZXNzaW9ucyIsInNlc3Npb25EYXRlIiwiZ2FtZXNQbGF5ZWQiLCJ3YWdlcmVkIiwid29uIiwicHVzaCIsInRvTG9jYWxlRGF0ZVN0cmluZyIsIndlZWtkYXkiLCJmdWxsRGF0ZSIsInNwbGl0IiwiZ2V0R2FtZVR5cGVTdGF0cyIsImdhbWVUeXBlcyIsImdhbWVTZXNzaW9ucyIsInN0YXRzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/gameSessionStorage.ts\n"));

/***/ })

});